记文本串为 txt，其长度为 $m$，模式串为 pat，其长度为 $n$。均从 $1$ 开始编号。

## 暴力做法

> 下面的代码中的 $f[i]$ 表示文本串中以 $i$ 结尾的子串与模式串的前缀能够匹配的最大长度

![屏幕截图 2023-10-27 103822](C:\Users\Lee\OneDrive\桌面\屏幕截图 2023-10-27 103822.png)

我们用指针 $i$ 指向文本串开始比较的位置，用指针 $j$ 指向模式串已经比较过且和文本串相同的位置。

接下来，我们将 `txt[i+j]` 和 `pat[j + 1]` 进行比较，如果相等的话，那么 $j$ 右移一位，进行下一次比较。如果不等的话，说明匹配失败，指针 $i$ 右移一位，$j$ 回退到 $0$。重新进行下一轮比较。

```c++
for (int i = 1, j = 0; i + j <= m; i++) {
  while (j < n && txt[i + j] == pat[j + 1]) {
      j++;    
  }
  f[i] = j;
  j = 0; // 指针 j 回退到位置 0
}
```

下面的代码中，用 $i$ 表示文本串当前准备比较的比较的位置，即 $i$ 相当于上面代码中的 $i + j$。该调整没有任何优化作用，但可以方便我们理解 `KMP` 算法。

![屏幕截图 2023-10-27 112320](C:\Users\Lee\OneDrive\桌面\屏幕截图 2023-10-27 112320.png)

我们用 `txt[i]` 和 `pat[j + 1]` 匹配，如果匹配成功的话，指针 $j$ 和 $i$ 均右移一位，否则，$j$ 回退到 $0$ 的位置，$i$ 回退到 $i - j$ 的位置（这是这轮比较文本串开始的位置）。

```c++
for (int i = 1, j = 0; i <= m; i++) {
  if (j < n && txt[i] == pat[j + 1]) {
      j++;
  }
  else i -= j, j = 0;
  f[i] = j;
}
```

上面的代码中，进入阶段 $i$ 之前，都保持文本串中以 $i - 1$ 结尾的子串与模式串中长度为 $j$ 的前缀相匹配。进入阶段 $i$ 之后，我们只需检查 $\text{txt}[i]$ 是否与 $\text{pat}[j + 1]$ 相等即可。

## KMP 算法

在暴力做法中，当匹配失败的时候，文本串的指针 $i$ 回退到了开始比比较的位置，模式串的指针回退到了位置 $0$ 。注意到 $\text{txt}[i-j+1\sim i] = \text{pat}[1\sim j]$。利用这个信息我们可以减少不必要的回退。

![屏幕截图 2023-10-29 161134](C:\Users\Lee\OneDrive\笔记\算法学习\assets\屏幕截图 2023-10-29 161134.png)

当我们将指针 $i$ 回退的时候，相当于将模式串 `pat` 右移。右移多少呢？需满足两个条件：

1. 设右移后与 $i - 1$ 对应的位置为 $j_0$，那么 $\text{pat}[1 \sim j_0] = \text{txt}[?\sim i-1$]，这里用问号表示是因为我们并不关心问号具体的值，只要这两个子串相等即可。又因为$\text{pat}[1 \sim j] $已和 txt 中以 $i - 1$ 结尾的子串相匹配，故 $j_0$ 满足条件 $\text{pat}[1 \sim j_0] = \text{pat}[j-j_0+1, j$] 即可。

   ![屏幕截图 2023-10-29 161546](C:\Users\Lee\OneDrive\笔记\算法学习\assets\屏幕截图 2023-10-29 161546.png)
   
   ![屏幕截图 2023-10-29 161402](C:\Users\Lee\OneDrive\笔记\算法学习\assets\屏幕截图 2023-10-29 161402.png)

​      上面两幅图模式串移动的位置均满足条件1。但应该移动多少呢？

2. 移动的距离越少越好，这样才不会错过可能的解。

![屏幕截图 2023-10-29 162124](C:\Users\Lee\OneDrive\笔记\算法学习\assets\屏幕截图 2023-10-29 162124.png)

比如说上面的图例中，我们右移一步，两步，三步都满足条件1，但如果移动的距离超过一步，便错过了可能的解。右移的距离尽可能小，那么 $j_0$ 的值需尽可能的大。

我们记 $j_0={\rm next} [j]$。那么 $j_0$ 为满足条件 $j_0<j$，且 $A[j-j_0+1 \sim j]=A[1 \sim j_0]$ 的最大值。

```c++
for (int i = 1, j = 0; i <= m; i++) {
    while (j > 0 && (j == n || txt[i] != pat[j + 1])) j = next[j];
    if (txt[i] == pat[j + 1]) j++;
    f[i] = j;
}
```

这里的 $j$ 依然和前面暴力算法中的 $j$ 维持相同的性质：进入阶段 $i$ 之前，$j$ 是 文本串中以 $i - 1$ 结尾的子串能够匹配的最长前缀。

## 求 next 数组

注意到 next 数组和 f 数组的定义相似，求 next 数组相当于 pat 和自身匹配。故计算代码类似。

```c++
next[1] = 0;
for (int i = 2, j = 0; i <= n; i++) {
  while (j > 0 && pat[i] != pat[j + 1]) j = next[j];
  if (pat[i] == pat[j + 1]) j++;
  next[i] = j;
}
```



