---
title: 初级数据结构1
updated: 2022-08-09 06:26:10Z
created: 2019-07-24 10:58:52Z
---

[toc]
#####单调栈
性质：
* 若是单调递增栈，则从栈底到栈顶的元素是严格递增的。若是单调递减栈，则从栈底到栈顶的元素是严格递减的。
* 越靠近栈顶的元素越后进栈。

单调栈一般只能在栈顶操作，因此一般在应用单调栈的地方不限顶栈的大小，否则可能会造成元素无法进栈。
进栈过程：对于单调递增栈，若当前进栈元素为e，从栈顶开始遍历元素，把大于或等于e的元素弹出栈，直到遇到一个小于e的元素或者栈为空为止，然后再把e压入栈中。对于单调递减栈，则每次弹出的是小于或者等于e的元素。

```c++
int st[10000];   // 栈
int top = 0;     // 栈内元素个数
void ins(int e)   // 单调递增栈，插入元素e
{
    while (top > 0 && st[top] >= e)
    {
        top--;
    }
    st[++top] = e;
}

```

######例1
@import "1.1.md"

#####单调队列
在谈及单调栈时，我略去了栈的大小这一个问题，因为在实际使用中（比如函数调用栈）栈就通常没有大小的概念。而对于队列，它的大小就很重要了。
如果队列满了，我们的解决方法是，将队列头的元素弹出，再添加新的元素到队列尾。

**具体入队过程**
对于单调递增队列，设当前准备入队的元素为e，从队尾开始把队列中的元素逐个与e对比，把比e大或者与e相等的元素逐个删除，直到遇到一个比e小的元素或者队列为空为止，然后把当前元素e插入到队尾。
对于单调递减队列也是同样道理，只不过从队尾删除的是比e小或者与e相等的元素。

```c++
void ins(int x) // 去长度为k的区间的最大值
{
    while (l < r && q[r - 1] <= a[x])
        r--;
    q[r] = a[x];
    inq[r] = x;
    r++;
}

int getMax(int cur) 
{
    for (; l < r; l++)
        if (cur - inq[l] < k)
            return q[l];
}
```
######例2
@import "1.2.md"
* P1886（滑动窗口）


#####优先队列
* P1090（合并果子）
#####前缀和

* 带修改的前缀和

* 差分
例：有 $n$ 组操作，每次是将 $[l, r]$ 中的数增加 $x$ 。
* 二维前缀和
p3406
#####并查集
* MakeSet
* Union
* FindSet
p3367(模版)
p1551(裸题)
p1197
#####带权并查集合并
* NOIP2010 关押罪犯
#####线段树
```c++
int sumv[N<<2];
void pushup(int o)
{
    sumv[o] = sumv[o<<1] + sumv[o<<1|1];
}
void build(int o, int l, int r)
{
    if (l == r)
    {
        sumv[o] = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(o<<1, l, mid);
    build(o<<1|1, mid + 1, r);
    pushup(o);
}

//单点修改
void change(int o, int l, int r, int q, int v)
{
    if (l == r)
    {
        sum[o] += v;
        return;
    }
    int mid = (l + r) >> 1;
    if (q <= mid)
        change(o << 1, l, mid, q, v);
    else
        change(o << 1|1, mid + 1, r, q, v);
    pushup(o);
}
```

#####树状数组
* 逆序对 P1908

#####扫描线


