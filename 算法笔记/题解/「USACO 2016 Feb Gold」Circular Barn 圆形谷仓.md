不影响题意， 不妨认为每个房间最开始有 $C_i$ 头奶牛。

如果一个最优方案中，每个房间都有奶牛从旁边房间走过来的话，那么，可以让每个房间都少走出一头奶牛，这样，每个房间最终的奶牛数依然不变，但消耗的能量变少。所以，任意一个最优方案中，一定存在某个房间，没有奶牛从旁边房间走入。这样的房间我们成为起点。假设第 $x$ 个房间为某个最优方案的起点。那么 $C_x, C_{x+ 1}, C_{x+2}, \cdots, c_n, c_1, \cdots, c_{x-1}$ 满足任意前 $i$ 个数的和大于等于 $i$。

另外，如果一头奶牛 $A$ 行走的路线经过了另一头奶牛 $B$ 的路线的起点和终点，那么我们交换 $A、B$ 的终点，最终结果没有变化，但消耗的能量变少。比如 $A$ 从 $x$ 走到 $y$，$B$ 从 $a$ 走到 $b$。

其中 $x \le a \le b \le y$，不交换的话总共消耗的能量为 $(y - x)^2 + (b - a)^2$。交换后消耗的能量为 $(b - x)^2 + (y - a)^2$​。可以发现前者大于等于后者。

现在，我们从房间 $x$ 开始处理每个房间。

#### 举个具体的例子

$6$ 个房间，奶牛数分别为 $3,0,2,0,0,1$。

第一个房间，我们应该拿走两头奶牛。能量消耗为 $0$ 。

第二个房间，我们应放入 $1$ 头奶牛。该奶牛的能量消耗为 $1$。

第三个房间，我们应将房间内的两头奶牛带走，同时，放入第一个房间带出的奶牛，该奶牛的能量消耗为 $4$。

第 $4$ 个房间，我们放入从第三个房间带入的奶牛，该奶牛消耗为 $1$。

第 $5$ 个房间，我们放入从第三个房间带入的奶牛，该奶牛消耗为 $4$。

第 $6$​ 个房间，不作任何处理。

#### 一般情况下

用一个集合保存前面多余的奶牛，每次到一个新的房间，我们将当前房间的奶牛取出放入我们的集合中，然后，在集合中选一个最远距离的奶牛放入该房间。在具体实现的时候，可以一个队列来模拟该操作。

#### 哪个位置作为起点最优呢

可能有多个位置都可以作为合法的起点，但具体选哪个呢？结论是任意一个都可以。

比如向下面的例子:

$x, ...., y....$

$x$ 和 $y$ 都是可以作为起点的地方，按照我们的计算办法，并没有奶牛从左边进入房间 $y$。所以，我们从 $y$ 开始处理每个房间，能量消耗不会变化。

#### 如何找到一个合法的位置呢

我们从位置 $i$ 开始求前缀和，最开始 $i = 1$。若在某个位置 $j$ 发现 前缀和为负，则意味着 $i \sim j$ 的位置都不能作为起点，令 $i = j + 1$，继续上面的操作。

#### 参考代码

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, c[N << 1];

int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) cin >> c[i], c[i + n] = c[i];
  
  int st = 1;
  int sum = 0;
  for (int i = 1; i <= n; i++) {
    sum += c[i] - 1;
    if (sum < 0) { sum = 0; st = i + 1;}
  }

  queue<int> q;
  long long ans = 0;
  for (int i = st; i < st + n; i++) {
    for (int j = 1; j <= c[i]; j++) q.push(i);
    ans += (i - q.front()) * (i - q.front());
    q.pop();
  }
  cout << ans << endl;
}
```









