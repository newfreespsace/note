---
title: 递归
updated: 2022-08-09 06:26:08Z
created: 2019-07-27 14:25:09Z
---

[toc]
## 第二节 递归
### 0.引言
当函数的定义中，其内部操作又直接或间接地出现对自身的调用，则称这样的程序嵌套定义为递归定义。

* 在数列中，我们可以通过直接给出数列的通项公式得到整个数列，例如数列$2，5，8，11，14，...，$的通项公式为$a_n=3n-1$，那么我们可以通过代入$n$的值得到我们所需要的项，例如$a_4=3*4-1=11$。
但同时，我们也可以通过下面的方式来定义这个数列：

$$ a_n=\left\{
\begin{aligned}
2 \quad   (n = 1) \\
a_{n-1} + 3 \quad (n \ge 2)
\end{aligned}
\right.
$$

* 阶乘也可这样来定义：
$$ n!=\left\{
\begin{aligned}
1 \quad   (n = 0) \\
n*(n-1)! \quad (n \ge 1)
\end{aligned}
\right.
$$
<br>
> **递归通常把一个大型复杂的问题转化成更小输入的相同问题来解决原来的问题。**

###1.一些通过递归解决的问题。
---
####例1
给出计算 $n!$ 的递归算法，其中 $n$ 是一个非负整数。
```c++
int factorial(int n)
{
    if (n == 0)
        return 1;
    return n * factorial(n - 1);
}
```
---
####例2
设计一个递归算法求数列$2，5，8，11，14，...，$的第 $n$ 项。
```c++
int order(int n)
{
    if (n == 1)
        return 2;
    return 3 + order(n - 1);
}
```
---
####例3
设计一个递归算法计算$a^n$。
```c++
int power(int a, int n)
{
    if (n == 0)
        return 1;
    return a * power(a, n - 1);
}
```
---
####例4
设计一个递归算法计算两个非负整数$a，b$的最大公因数。
考虑$gcd(a, b) = gcd(b, a \% b)$。

```c++
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    return gcd (b, a % b);
}
```
####例5
斐波拉切数列的前几项分别为$1，1，2，3，5，8，...，$，即后一项是其前两项的和。求该数列的第 $n$项。







###拓展



####例6
>有 $n$ 个圆盘，依半径大小（半径都不同），每次只允许移动最上面一个盘子到另外的柱子上去（除 $a$ 柱外，还有 $b$ 柱子和 $c$ 柱，开始时这两个柱子上无盘子），但决不允许出现大盘子在上，小盘子在下的情况，现要求设计将 $a$ 柱子上 $n$ 个盘子搬移到 $c$ 柱去的方法。


</br>
</br>
</br>
</br>

```c++
void move(int n, char a, char b, char c) // n 个盘子通过b中转，从a移动到c
{
    if (n == 0)
        return;
    move(n - 1, a, c, b);
    cout << a << "==>" << c << endl;
    move(n - 1, b, a, c);
}
```


</br>
</br>
</br>


####例7
>给出$n$个整数$(n \le 25)$，又已知一整数$m$。如能使数组$a$中任意几个元素之和等于$m$，则输出YES，反之则输出NO。

<br>

**输入**
>第一行：一个小于等于25的正整数n。
第二行：n个整数，以空格隔开
第三行：整数m。

<br>

**输出**
>如题意所示

<br>

**输入样例**
>4
1 2 3 5
10

<br>

**输出样例**
>YES

<br>

**参考代码**
```c++
void sum(int n, int m)
{
    if (a[n] == m)
    {
        flag = true;
    }
    else if (n == 1)
           return;
    else
    {
        if (!flag)
            sum(n - 1, m - a[n]);
        if (!flag)
            sum(n - 1, m);
    }
}

```


####例8v
>组合
从n个不同元素中取m个出来，求不同的方法数。




>集合的划分
把一个有 $n$ 个元素的集合划分为 $k$ 个子集合的方法数。



