---
title: 状态压缩
updated: 2022-08-09 06:26:10Z
created: 2019-10-28 11:05:50Z
---

## 状态压缩DP


* 位运算

|含义|写法|
- | :-: | :-: | -:
|按位与|a & b|
|按位或|a \| b|
|按位异或|a ^ b|
|按位取反|~a|
|左移|a << b|
|右移|a >> b|



1. 取出整数$n$在二进制表示下的第$k$位。
```c++
(n>>k) & 1
```
2. 取出整数$n$在二进制表示下的第$0 \sim  k - 1$位（后$k$位）
```c++
n & ((1<<k) - 1)
```
3. 整数$n$在二进制表示下的第$k$位取反。
```c++
x ^ (1<<k)
```
4. 对整数$n$在二进制表示下的第$k$位赋值1。
```c++
n | (1<<k)
```
5. 对整数$n$在二进制表示下的第$k$位赋值0。
```c++
n & (~(1<<k))
```

6. 将整数$n$的最后一个1置0。
```c++
n & (n - 1)
```
6. lowbit
```c++
lowbit(n) = n & (~n+1) = n & (-n)
```

#### 例一
在$n*n(n \le 20)$的方格棋盘上放置$n $个车(可以攻击所在行、列)，求使它们不能互相攻击的方案总数。因为结果可能会很大，所以对$100001$求余。

```c++
f[0] = 1;

for (int i = 1; i < (1 << n); i++)
{
    for (int j = i; j > 0; j -= lowbit(j))
    {
        f[i] += f[i & ( ~lowbit(j) )];
    }
}
```
实际上，定义的状态为f(s, i), 表示第i行状态为s的情况数，但i的值实际上为s中1的个数，所以可以省略。

#### 例二
在$n \times n(n \le 20)$的方格棋盘上放置$n$个车，某些格子不能放，求使它们不能互相攻击的方案总数。因为结果可能会很大，所以对$100001$求余。

```c++
f[0] = 1;
for(int i = 1;i < 1<<n; i++){
    int num = 0;
    for( int j = i;j > 0;j -= lowbit(j) )
        num++; //计算 i 这一个状态 1 的个数，即当前处理的行数 
    for(int j = i;j > 0;j -= lowbit(j) ) {
        if( !(vist[num] & lowbit(j) ) //判断该位置是否可以放置
            f[i] += f[ i & ~lowbit(j) ];
    }
}
```

#### 例3：
给定一个$m（m \le 10)$行$n(n \le 1000)$列的棋盘，找出放置$m$个车的方案总数。输出总方案数对1234567的余数。
```c++
for (int i = 0; i <= n; i++)
    f[0][i] = 1;
    
for (int i = 1; i <= n; i++)
{
    for (int s = 1; s < 1<<m; s++)
    {
        f[s][i] = f[s][i - 1];

        for (int k = 0; k < m; k++)
        {
            if ( (s>>k) & 1 )
            {
                f[s][i] += f[s ^ (1<<k)][i - 1];
            }
        }
    }
}
```


#### 例4 
把$n \times m$的棋盘分割成若干个$1 \times 2$的长方形，有多少种方案。
例如：n = 2, m = 4时有5种方案。n = 2, m = 3时有3种方案。





