---
title: 线段树
updated: 2022-08-09 06:26:47Z
created: 2019-07-29 16:23:37Z
---

## 线段树
>块的思想，则是可以用一句话总结为：通过将整个序列分为有穷个小块，对于要查询的一段区间，总是可以整合成kk个所分块与mm个单个元素的信息的并($0<=k,m<=\sqrt{n}$)

#### 1.建树与维护
由于二叉树的自身特性，对于每个父亲节点的编号ii,他的两个儿子的编号分别是2i2i和2i+12i+1，所以我们考虑写两个O(1)O(1)的取儿子函数：
```c++
int n;
int ans[MAXN*4]; 

inline int ls(int p)
{
    return p<<1; 
} //左儿子

inline int rs(int p)
{
    return p<<1|1;
} //右儿子 
```
* 1、此处的inline可以有效防止无需入栈的信息入栈，节省时间和空间。

* 2、二进制位左移一位代表着数值*2∗2，而如果左移完之后再或上11，由于左移完之后最后一位二进制位上一定会是00，所以|1∣1等价于+1+1。

#####维护
```c++
void push_up_sum(int p){
    t[p]=t[lc(p)]+t[rc(p)];
}// 向上不断维护区间操作 

void push_up_min(int p){//max and min
     t[p]=min(t[lc(p)],t[rc(p)]);
     //t[p]=max(t[lc(p)],t[rc(p)]);         
}
```
此处一定要注意，pushup操作的目的是为了维护父子节点之间的逻辑关系。当我们递归建树时，对于每一个节点我们都需要遍历一遍，并且电脑中的递归实际意义是先向底层递归，然后从底层向上回溯，所以开始递归之后必然是先去整合子节点的信息，再向它们的祖先回溯整合之后的信息。(这其实是正确性的证明啦)

呐，我们在这儿就能看出来，实际上pushup是在合并两个子节点的信息，所以需要信息满足结合律！

那么对于建树，由于二叉树自身的父子节点之间的可传递关系，所以可以考虑递归建树，并且在建树的同时，我们应该维护父子节点的关系：
```c++
void build(ll p,ll l,ll r)
{
    if(l==r){ans[p]=a[l];return ;}
    //如果左右区间相同，那么必然是叶子节点啦，只有叶子节点是被真实赋值的
    ll mid=(l+r)>>1;
    build(ls(p),l,mid);
    build(rs(p),mid+1,r);
//此处由于我们采用的是二叉树，所以对于整个结构来说，可以用二分来降低复杂度，否则树形结构则没有什么明显的优化
    push_up(p);
//此处由于我们是要通过子节点来维护父亲节点，所以pushup的位置应当是在回溯时。
}
```
####区间修改


