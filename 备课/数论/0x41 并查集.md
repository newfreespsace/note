---
title: 0x41 并查集
updated: 2022-09-04 07:35:04Z
created: 2022-09-04 06:45:13Z
latitude: 31.46749500
longitude: 104.67894600
altitude: 0.0000
---

## 0x41 并查集

在这里，我们将实现一种可以动态维护若干个不重叠集合的数据结构。支持合并两个集合和查询两个两个元素是否在同一个集合的操作。

我们使用有根树来表示集合，每个节点表示一个元素，并且仅指向它的父节点。每棵树的根节点指向其自身，它将作为集合的代表出现。

并查集支持两个基本操作：
* ``Get`` 查询一个元素属于哪一个集合
在实现中通过不断的访问节点的父节点，直到得到根节点为止。
* ``Merge`` 把两个集合合并成一个集合
在实现中我们将一个集合所在的树的根节点指向另一颗树的根节点，这样，两个树合并成了一棵树，并且有了共同的根节点。

#### 代码实现
##### 初始化
```c++
for (int i = 1; i <= n; i++) fa[i] = i;
```

##### get 操作
```c++
int get(int x) {
    if (x == fa[x]) return x;
    return get(fa[x]);
}
```

##### merge合并
把两个集合合并成一个集合
```c++
void merge(int x, int y) {
    x = get(x);
    y = get(y);
    fa[x] = y;
}
```

### 启发式策略
#### 路径压缩
注意到我们只关心每个集合对应的 “树形结构的根节点“，因此，我们可以在每次执行 ``get`` 操作的时候，把访问过的每个节点（也就是所查询元素的全部祖先）都直接指向树根。

采用路径压缩优化的并查集，每次 ``get`` 操作的均摊复杂度为 $O(\log N)$。
```c++
int get(int x) {
    if (x == fa[x]) return x;
    return fa[x] = get(fa[x]);
}
```
#### 按秩合并
使具有较少节点的树的根指向具有较多节点的树的根。