#### 树形 DP 求树的直径

树的直径经过的节点中一定有一个节点最高，我们枚举每个节点 $x$，计算 $x$ 作为树的链经过的最高节点时，所能得到的链的最长长度 $F[x]$。那么 $F[x]$ 的最大值就是树的直径。

用 $D[x]$ 表示 $x$ 距离以它为根的子树的叶节点的最大距离。$D[x] = \max \{ D[y] + e(x, y)\}$，其中 $y$ 是 x 的儿子节点。

那么 $F[x] = \max \{ D[y_i] + e(x, y_i) + D[y_j]  + e(x, y_j)\}$，其中 $y_j、y_i$ 都是 $x$ 的儿子节点。

我们依次枚举 $x$ 的儿子节点 $y$，计算 $D[x]$，在枚举到节点 $y_i$ 的时候，$F[x] = \max \{ D[y_i] + e(x, y_i) + D[y_j]  + e(x, y_j)\} = \max \{ D[y_j]  + e(x, y_j) \}+ D[y_i] + e(x, y_i) $ 。而 $\max \{ D[y_j]  + e(x, y_j) \}$ 恰好保存在此时的 $D[x]$ 中。故直接通过 $D[x] + D[y_i] + e(x, y_i)$ 更新 $F[x]$ 即可，再通过 $D[y_i] + e(x, y_i)$ 更新 $D[x]$。

```c++
void dp(int x) {
  v[x] = true;
  for (auto [y, z] : vec[x]) {
    if (v[y]) continue;
    dp(y);
    ans = max(ans, d[x] + d[y] + z);
    d[x] = max(d[x], d[y] + z);
  }
}
```

### 两次 BFS 求树的直径

1. 从任意一个节点出发，通过 BFS 或 DFS 对树进行一次遍历，求出与出发点距离最远的节点，记为 $p$。

2. 从节点 $p$ 出发，通过 BFS 或 DFS 再进行一次遍历，求出与 $p$ 距离最远的节点，记为 $q$ 。

从 $p$ 到 $q$ 的路径就是树的一条直径

